{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n#\tAuthor:       VEX\n#\tCreated:\n#\tDescription:  VEXcode V5 Python Project\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\n\n# Begin project code\nfrom vex import *\nimport urandom\nimport time\nimport math\nimport random\n# constants for pneumatics\nOPEN = True\nCLOSE = False\n# brain\nbrain = Brain()\n# controller\ncontroller_1 = Controller(PRIMARY)\n# logging explanation\ncontroller_1.screen.set_cursor(1, 1)\ncontroller_1.screen.print(\"time\")\n\ncontroller_1.screen.set_cursor(2, 1)\ncontroller_1.screen.print(\"dt temps\")\n\ncontroller_1.screen.set_cursor(3, 1)\ncontroller_1.screen.print(\"cata temp\")\n# sensors\ndist = Distance(Ports.PORT2)\n\norientation = Inertial(Ports.PORT1)\norientation.calibrate()\nwhile orientation.is_calibrating():\n    wait(10, MSEC)\n# drivetrain\ndt_left = MotorGroup(\n    Motor(Ports.PORT11, GearSetting.RATIO_6_1, True),\n    Motor(Ports.PORT12, GearSetting.RATIO_6_1, True),\n    Motor(Ports.PORT13, GearSetting.RATIO_6_1, True)\n)\ndt_right = MotorGroup(\n    Motor(Ports.PORT20, GearSetting.RATIO_6_1, False),\n    Motor(Ports.PORT19, GearSetting.RATIO_6_1, False),\n    Motor(Ports.PORT18, GearSetting.RATIO_6_1, False)\n)\ndt_left.set_stopping(BRAKE) \ndt_right.set_stopping(BRAKE)\n# components\nintake = Motor(Ports.PORT8, GearSetting.RATIO_18_1, True)\ncatapult = Motor(Ports.PORT9, GearSetting.RATIO_18_1, False)\n# solenoids\nwings = DigitalOut(brain.three_wire_port.a)\nendg = DigitalOut(brain.three_wire_port.b)\n\nclass Components:\n    def __init__(self, cata_speed):\n        catapult.set_velocity(cata_speed, RPM)\n        intake.set_velocity(200, PERCENT)\n\n        self.wing_value = False\n        self.intake_value = None\n    def intake(self, direction):\n        if direction == None:\n            intake.stop()\n        else:\n            intake.spin(direction)\n        self.intake_value = direction\n    def catapult(self, direction=FORWARD):\n        if direction == None:\n            catapult.stop()\n        else:\n            catapult.spin(direction)\n    def wings(self, value=None):\n        if value == None:\n            self.wing_value = not self.wing_value\n        else:\n            self.wing_value = value\n        wings.set(self.wing_value)\nclass Drivetrain:\n    def __init__(self, gear_ratio, wheel_diameter, wheelbase):\n        self.gear_ratio = gear_ratio\n        self.wheel_diameter = wheel_diameter\n        self.wheelbase = wheelbase\n        self.dt_time = 0\n    def drive4(self, inches, speed=200, timeout=1):\n        first = brain.timer.time(SECONDS)\n        '''\n        ### I think this is the most used dt auton function; it simply drives a number of inches.\n        We are planning to eventually add a PID loop or something here later on.\n        A custom timeout solution end the command and moves on if the robot gets stuck or takes too long.\n\n        #### Arguments:\n            inches: how far to drive, in inches forward. Negative values are accepted and interpreted as inches backwards.\n            speed (>0, <100): speed of both sides, in percent\n            timeout (>0): DEPRECATED - do not use, full stop.\n        #### Returns:\n            None\n        #### Examples:\n            # slowly drive 24 inches (one tile):\n            dt.drive4(24, speed=25)\n            # drives across three tiles\n            dt.drive4(24*3)\n        '''\n        # speeds\n        dt_left.set_velocity(speed, PERCENT)\n        dt_right.set_velocity(speed, PERCENT)\n        # core spin\n        dt_left.spin_for(FORWARD, (inches/(math.pi*self.wheel_diameter))*self.gear_ratio, TURNS, wait=False)\n        dt_right.spin_for(FORWARD, (inches/(math.pi*self.wheel_diameter))*self.gear_ratio, TURNS, wait=False)\n        # record initial time; var to check if dt has accelerated\n        initial_time = brain.timer.time(SECONDS)\n        is_started = False\n        running = True\n        # main timeout loop\n        while running:\n            wait(10, MSEC)\n            # is_started makes sure we don't stop during accel\n            if dt_left.velocity(PERCENT) > 5:\n                is_started = True\n            # main checks\n            # if brain.timer.time(SECONDS)-initial_time >= timeout:\n            #     print(\"drive4 timed out: dist\", inches, \"timeout\", timeout)\n            #     running = False\n            if is_started and dt_left.velocity(PERCENT) == 0: # UTB elif\n                # recalculate as a form of error filtering\n                wait(40, MSEC)\n                running = not (dt_left.velocity(PERCENT) == 0)\n            \n        # stop\n        dt_left.stop()\n        dt_right.stop()\n        # logging\n        #print(\"drive4/done\", inches, \"in, took\", brain.timer.time(SECONDS)-initial_time, 'sec')\n        self.dt_time += brain.timer.time(SECONDS)-first\n    def turn2(self, angle_unmodded, speed=41):\n        '''\n        ### A turn-to-heading function which uses a feedback loop (just P for now) in tandem with the inertial to achieve very precise results.\n\n        #### Arguments:\n            angle_unmodded: angle turning to, in degrees clockwise. Negative inputs are allowed and will be interpreted as degrees counterclockwise. Reference point is set during calibration\n            speed (>0, <100): absolute speeds of both sides, in percent (41 has been empirically derived to be the fastest)\n        #### Returns:\n            None\n        #### Examples:\n            # slowly turn to a heading of 180Ëš:\n            dt.turn2(180, speed=15)\n            # draws a square\n            for i in range(4):\n                dt.turn2(i*90)\n                dt.drive4(10)\n        '''\n        # constants\n        angle = angle_unmodded % 360\n        initial_time = brain.timer.time(SECONDS)\n        # initial heading\n        h = orientation.heading(DEGREES)\n        # main loop\n        while abs(angle - h) % 360 > 1:\n            # calculations\n            h = orientation.heading(DEGREES)\n            vel = abs((angle - h + 180) % 360 - 180) * speed * 2 / 180 + 3\n            # action!\n            dt_left.spin(FORWARD if (angle - h + 180) % 360 - 180 > 0 else REVERSE, vel, PERCENT)\n            dt_right.spin(REVERSE if (angle - h + 180) % 360 - 180 > 0 else FORWARD, vel, PERCENT)\n            # wait\n            wait(10, MSEC)\n        # stop dt\n        dt_left.stop()\n        dt_right.stop()\n        # rerun if drift\n        if abs(angle - orientation.heading(DEGREES)) % 360 > 1:\n            self.turn2(angle, speed=10)\n        #print('turn2/done', angle_unmodded, 'deg', 'took', brain.timer.time(SECONDS)-initial_time, 'sec')\n    def arc(self, rad, head, side, duration, speed=65, finish=True):\n        '''\n        ### An arc function which allows us to skip parts in autons where we alternate between turn2's and drive4's.\n\n        #### Arguments:\n            rad (>0): Radius of arc, in inches\n            head (FORWARD/REVERSE): whether the robot is moving for/backwards\n            side (LEFT/RIGHT): which side the robot is arc towards\n            duration (>0): how long the arc should last, in seconds\n            speed (>0, <100): average speed of both sides, in percen\n        #### Returns:\n            None\n        #### Examples:\n            # slowly draw a circle with diameter of 20in\n            dt.arc(10, FORWARD, RIGHT, 7, speed=25)\n            # draws a rounded square\n            for i in range(4):\n                dt.drive4(2)\n                dt.arc(5, FORWARD, RIGHT, 1.5, speed=65) # adjust duration to make this a quarter circle\n        '''\n        # convert sides to numbers\n        aside = 1 if side == RIGHT else -1\n        ahead = 1 if head == FORWARD else -1\n        # targets for each side\n        left = ahead*(rad+aside*self.wheelbase/2) # the parenthesized portion is the abs value\n        right = ahead*(rad-aside*self.wheelbase/2) # of the circumference of the side's circle\n        # velocities\n        sconst = speed/(abs(left)/2+abs(right)/2) # to add the speed factor\n        print('fastarc', rad, head, side, duration, speed)\n        # and away she goes!\n        dt_right.spin(FORWARD, right*sconst*12/100, VOLT)\n        dt_left.spin(FORWARD, left*sconst*12/100, VOLT)\n        if not finish:\n            print(left*sconst, right*sconst)\n            return None\n        # wait, then stop\n        wait(duration, SECONDS)\n        dt_left.stop()\n        dt_right.stop()\n        # in case you need it - here's a simple fn to determine duration of an arc\n        '''\n        def test(rad):\n            dt.arc(..., finish=False)\n            initial_time = brain.timer.time(SECONDS)\n            while not controller_1.buttonB.pressing():\n                wait(1, MSEC)\n            dt_left.stop()\n            dt_right.stop()\n            print(brain.timer.time(SECONDS)-initial_time)\n        '''\n        \n       \ndt = Drivetrain(60/36, 3.25, 11)\n# (4/5)(motor rpm) = matchloads per minutes\ncp = Components(165) # 144 triballs per minute, 2.4 per sec\n# helper functions\ndef matchload_setup(mangle=20):\n    dt.drive4(12)\n    dt.turn2(180-mangle)\n    dt.drive4(12)\n    dt.drive4(2.5, speed=25)\n    # match loading\n    cp.catapult()\n    dt.turn2(180-mangle)\n# driver control\ndef driver_control():\n    # core archie setup\n    def print_all(msg):\n        controller_1.screen.clear_screen()\n        for i in range(3):\n            controller_1.screen.set_cursor(i+1,1)\n            controller_1.screen.print(msg)\n    log_n = 0 # a var to keep track of segregated logging\n    brain.timer.clear()\n    # skills mode + matchloading setup\n    hang_n = 10\n    skills = False\n    if controller_1.buttonY.pressing() or controller_1.buttonA.pressing():\n        skills = True\n        controller_1.rumble('-.-.-.')\n        print_all('SKILLS MODE')\n        orientation.set_heading(270, DEGREES)\n        matchload_setup()\n    # cp controls\n    controller_1.screen.clear_screen()\n    controller_1.buttonL2.pressed(cp.wings)\n    controller_1.buttonR2.pressed(cp.wings)\n\n    controller_1.buttonL1.pressed(lambda: cp.intake(None if cp.intake_value == FORWARD else FORWARD))\n    controller_1.buttonR1.pressed(lambda: cp.intake(None if cp.intake_value == REVERSE else REVERSE))\n\n    controller_1.buttonX.pressed(cp.catapult)\n    controller_1.buttonB.released(catapult.stop)\n\n    controller_1.buttonUp.pressed(lambda: endg.set(True))\n    controller_1.buttonDown.pressed(lambda: endg.set(False))\n    # ready, set, drive!\n    while True:\n        wait(10, MSEC)\n        # dt controls\n        straight_speed = controller_1.axis3.position()\n        turn_speed = 0.5*controller_1.axis1.position()\n        l = straight_speed + turn_speed\n        r = straight_speed - turn_speed\n        dt_left.spin((FORWARD if l >= 0 else REVERSE), abs(l)*12/100, VOLT)\n        dt_right.spin((FORWARD if r >= 0 else REVERSE), abs(r)*12/100, VOLT)\n        # logging\n        logs = [\n            \"time: %d:%g\" % (math.floor(brain.timer.time(SECONDS)/60), int(brain.timer.time(SECONDS) % 60)),\n            \"dt: %d %d\" % (dt_left.temperature(PERCENT), dt_right.temperature(PERCENT)),\n            \"cata: %d\" % catapult.temperature(PERCENT),\n        ]\n        controller_1.screen.set_cursor(1 + log_n % 3, 1)\n        controller_1.screen.print(logs[log_n % 3])\n        log_n += 1\n        # hang mode\n        if brain.timer.time(SECONDS) > 50 and skills and hang_n > 0:\n            if hang_n == 10:\n                endg.set(True)\n            print_all('HANG MODE')\n            hang_n -= 1\n            if hang_n == 0:\n                controller_1.screen.clear_screen()\ndef autonomous():\n    mangle = 20\n    def matchload(start=False):\n        if start:\n            orientation.set_heading(270)\n        matchload_setup(mangle=mangle)\n        loads = 45\n        load_const = (45/37)*(5/4) # multiply desired # of matchloads by (45/37)*(5/4) - 5/4 due to gear ratio, 45/37 for error correction?\n        catapult.spin_for(FORWARD, 45*load_const, TURNS, wait=False) \n        while catapult.is_spinning():\n            if catapult.position(TURNS) > load_const*(loads-3):\n                intake.spin(FORWARD)\n            wait(50, MSEC)\n    def traverse(start=False):\n        intake.stop()\n        if start:\n            orientation.set_heading(180-mangle)\n        # switch to offensive zone\n        dt.drive4(-3)\n        dt.turn2(45)\n        dt.drive4(21)\n        dt.turn2(180)\n        dt.drive4(-33-24-3, timeout=3)\n    def pushes(start=False):\n        \"\"\"\n        NEW AUTON SKILLS, starting after match loading (26s)\n        Offshoot -> reduce matchload angle\n        * go over barrier straight -> arc into elevation side push (11 sec)\n        * transition phase (4 sec)\n        * same center arcs - last center straight changed? (11 sec)\n        \"\"\"\n        if start:\n            orientation.set_heading(180, DEGREES)\n            dt.drive4(-3)\n        # arc back for right side push\n        dt.arc(20, REVERSE, RIGHT, 1.2, speed=65)\n        dt.drive4(-10)\n        dt.drive4(5)\n        dt.drive4(-5)\n        dt.drive4(5)\n        # dive into the heart of the enemy - i mean offensive zone\n        dt.turn2(0)\n        dt.drive4(-10)\n        dt.turn2(15)\n        dt.drive4(-32)\n        # angle push 1\n        dt.turn2(155)\n        dt.drive4(-24)\n        # traverse to next push\n        dt.drive4(7)\n        dt.turn2(180)\n        dt.drive4(12)\n        dt.turn2(-90)\n        dt.drive4(46, timeout=3)\n        # angle push 2\n        dt.turn2(33)\n        dt.drive4(30)\n        dt.turn2(33)\n        # center push 1\n        dt.arc(9.5, REVERSE, RIGHT, 1.5)\n        dt.turn2(180)\n        cp.wings(OPEN)\n        dt.drive4(-20)\n        dt.drive4(10)\n        dt.drive4(-18, speed=200)\n        cp.wings(CLOSE)\n        # center push 2 at a slightly diff angle\n        dt.drive4(18, speed=200)\n        dt.turn2(160)\n        cp.wings(OPEN)\n        dt.drive4(-26)\n        dt.drive4(7, speed=200)\n        cp.wings(CLOSE)\n        # side push 2\n        dt.turn2(93)\n        dt.drive4(-12)\n        cp.wings(OPEN)\n        dt.arc(9, REVERSE, LEFT, 1.5, speed=65) # reuse arc from first side push\n        cp.wings(CLOSE)\n        dt.drive4(-5, speed=200)\n\n    sequence = [matchload, traverse, pushes]\n    test_sequence = [pushes]\n\n    dt_left.set_stopping(HOLD)\n    dt_right.set_stopping(HOLD)\n    brain.timer.clear()\n    first = True\n    for s in sequence:\n        s(first)\n        first = False\n    print(brain.timer.time(SECONDS))\n    brain.screen.print(brain.timer.time(SECONDS))\n\nprint(\"\\033[2J\") # clear console\ncompetition = Competition(driver_control, autonomous)","textLanguage":"python","rconfig":[],"slot":0,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}