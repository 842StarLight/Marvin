{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n# this is a *very* toned-down version of core, NOT UP TO DATE. I have removed most ports, classes, and methods to focus on the main goal: coding a PID controller to use for the turn2 function, and eventually, the drive4 function.\norientation = Inertial(Ports.PORT20)\norientation.calibrate()\n\ndt_left = MotorGroup(Motor(Ports.PORT2, GearSetting.RATIO_6_1, True), Motor(Ports.PORT1, GearSetting.RATIO_6_1, True))\ndt_right = MotorGroup(Motor(Ports.PORT9, GearSetting.RATIO_6_1, False), Motor(Ports.PORT10, GearSetting.RATIO_6_1, False))\n\ndt_left.set_stopping(BRAKE)\ndt_right.set_stopping(BRAKE)\n\nclass PID:\n    \"\"\"\n    Basic PID controller implemented in Python\n    Given a error (between -1 and 1), it tries to optimize the error towards 0\n    It is also given time steps (calculated using brain's internal coder)\n\n    init(initial error, initial time)\n\n    update(new error, new time) -> value\n    \"\"\"\n    def __init__(self, initialError, initialTime, constants = {\"kp\": 0.125, \"kd\": 0, \"ki\": 0}):\n        self.constants = constants\n        self.history = [(initialTime, initialError)]\n    def update(self, newError, newTime):\n        # Proportion Controller\n        print(self.constants[\"kp\"], newError)\n        p_out = self.constants[\"kp\"]*newError\n        # Derivative Controller\n        previousPoint = self.history[-1]\n        dt = newTime - previousPoint[0]\n        dx = newError - previousPoint[1]\n        derivative = dx/dt\n        d_out = derivative * self.constants[\"kd\"]\n        # Integral Controller (optional)\n        i_out = 0\n        # sum and return output\n        self.history.append((newTime, newError))\n        return p_out + d_out + i_out\n\nwait(1.5, SECONDS)\nprint(\"Calibration complete. Starting in 0.5 seconds.\")\nwait(0.5, SECONDS)\n\ndef turn2(angle_u, speed=30):\n    angle = angle_u % 360\n\n    def get_error():\n        h = orientation.heading(DEGREES)\n        e = (h-angle)%360\n        error = -(360-e)/180 if e > 180 else e/180\n        return error\n    virtual_controller = PID(initialError=get_error(), initialTime=brain.timer.time(MSEC))\n    while True:\n        wait(100, MSEC)\n        v = -virtual_controller.update(get_error(), brain.timer.time(MSEC))\n\n        print(get_error(), v)\n        # test 2: comment out lines 53-57; test 3: uncomment it and test full stack; test 4: change while condition and finish testing\n        dt_left.set_velocity(abs(v)*100, PERCENT)\n        dt_right.set_velocity(abs(v)*100, PERCENT)\n        \n        dt_left.spin(FORWARD if v<0 else REVERSE)\n        dt_right.spin(REVERSE if v<0 else FORWARD)\n\n       \n\n# test 1\n# test 2+ dt.turn2(90)\nturn2(angle_u=90)\n\"\"\"\nTest 1: test error calculations\nTest 2: test PID loop\nTest 3: test full stack\nTest 4: test in varying conditions\n\ndrive4:\nerror scale: distance to point\nsimilar error calculation\n\"\"\"","textLanguage":"python","rconfig":[],"slot":3,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[],"v5SoundsEnabled":false,"target":"Physical"}